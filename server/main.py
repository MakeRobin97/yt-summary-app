from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional
from urllib.parse import urlparse, parse_qs
from pathlib import Path
import os
import time

from dotenv import load_dotenv
from openai import OpenAI
import httpx
from youtube_transcript_api import (
    YouTubeTranscriptApi,
    TranscriptsDisabled,
    NoTranscriptFound,
)
import youtube_transcript_api as yta
import yt_dlp
import tempfile
import shutil
import hashlib
import json
import time
import random

# .env Î°úÎìú (server Ìè¥Îçî Í∏∞Ï§Ä)
load_dotenv(dotenv_path=Path(__file__).parent / ".env", encoding="utf-8", override=True)

# ÌôòÍ≤ΩÎ≥ÄÏàòÎßå ÏÇ¨Ïö© (ÌïòÎìúÏΩîÎî© Í∏àÏßÄ)

# Í∞ÑÎã®Ìïú Î©îÎ™®Î¶¨ Ï∫êÏãú (Ïã§Ï†ú Ïö¥ÏòÅÏóêÏÑúÎäî Redis ÏÇ¨Ïö© Í∂åÏû•)
CACHE = {}

def get_cache_key(video_id: str) -> str:
    """ÎπÑÎîîÏò§ IDÎ°ú Ï∫êÏãú ÌÇ§ ÏÉùÏÑ±"""
    return f"video_{video_id}"

def get_cached_result(video_id: str) -> Optional[dict]:
    """Ï∫êÏãúÏóêÏÑú Í≤∞Í≥º Ï°∞Ìöå"""
    cache_key = get_cache_key(video_id)
    return CACHE.get(cache_key)

def set_cached_result(video_id: str, result: dict) -> None:
    """Í≤∞Í≥ºÎ•º Ï∫êÏãúÏóê Ï†ÄÏû•"""
    cache_key = get_cache_key(video_id)
    CACHE[cache_key] = result
    # Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Ï†úÌïú (ÏµúÎåÄ 100Í∞ú Ìï≠Î™©)
    if len(CACHE) > 100:
        # Í∞ÄÏû• Ïò§ÎûòÎêú Ìï≠Î™© Ï†úÍ±∞
        oldest_key = next(iter(CACHE))
        del CACHE[oldest_key]

app = FastAPI(title="yt-summary-api")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/health")
def health_check():
    return {"status": "ok"}


@app.get("/")
def root():
    return {"message": "YT Summary API"}


@app.get("/version")
def version():
    return {
        "commit": os.getenv("RENDER_GIT_COMMIT") or os.getenv("GIT_COMMIT") or None,
        "branch": os.getenv("RENDER_GIT_BRANCH") or os.getenv("GIT_BRANCH") or None,
        "youtube_transcript_api": getattr(yta, "__version__", None),
        "yt_dlp": getattr(yt_dlp, "__version__", None),
        "openai": os.getenv("OPENAI_API_KEY") is not None,
        "features": ["whisper_only"],
    }


class SummarizeRequest(BaseModel):
    url: str


class SummarizeResponse(BaseModel):
    language: Optional[str]
    summary: str


class ChatRequest(BaseModel):
    message: str


class ChatResponse(BaseModel):
    response: str


def extract_video_id(youtube_url: str) -> Optional[str]:
    try:
        parsed = urlparse(youtube_url)
        if parsed.netloc in {"www.youtube.com", "youtube.com", "m.youtube.com"}:
            qs = parse_qs(parsed.query)
            return qs.get("v", [None])[0]
        if parsed.netloc in {"youtu.be"}:
            return parsed.path.lstrip("/") or None
        return None
    except Exception:
        return None


def _apply_optional_proxy_from_env() -> None:
    proxy = os.getenv("YOUTUBE_PROXY")
    if proxy:
        os.environ.setdefault("HTTP_PROXY", proxy)
        os.environ.setdefault("HTTPS_PROXY", proxy)
        print(f"üåê ÌîÑÎ°ùÏãú ÏÑ§Ï†ïÎê®: {proxy}")


def _with_backoff(callable_fn, *args, **kwargs):
    delays = [1, 3, 7, 12]
    last_err = None
    for delay in [0] + delays:
        if delay:
            time.sleep(delay)
        try:
            return callable_fn(*args, **kwargs)
        except Exception as e:
            msg = str(e)
            last_err = e
            print(f"Î∞±Ïò§ÌîÑ Ï§ë Ïò§Î•ò Î∞úÏÉù: {msg}")
            
            # Ï†ëÍ∑º Ï†úÌïú Ïò§Î•òÏù∏ Í≤ΩÏö∞ Ï¶âÏãú Ïã§Ìå®
            if _is_access_restricted_error(msg):
                print(f"Ï†ëÍ∑º Ï†úÌïú Ïò§Î•ò Í∞êÏßÄ, Î∞±Ïò§ÌîÑ Ï§ëÎã®: {msg}")
                raise e
            # 429 Ïò§Î•òÎßå Ïû¨ÏãúÎèÑ
            if any(tok in msg for tok in ["Too Many Requests", "429", "sorry/index"]):
                print(f"429 Ïò§Î•ò, Ïû¨ÏãúÎèÑ ÏòàÏ†ï: {msg}")
                continue
            print(f"Í∏∞ÌÉÄ Ïò§Î•ò, Ï¶âÏãú Ïã§Ìå®: {msg}")
            raise
    raise last_err


def _is_429_error(error_msg: str) -> bool:
    """429 Ïò§Î•òÏù∏ÏßÄ ÌôïÏù∏"""
    return any(tok in error_msg for tok in ["Too Many Requests", "429", "sorry/index"])


def _is_access_restricted_error(error_msg: str) -> bool:
    """Ï†ëÍ∑º Ï†úÌïú Í¥ÄÎ†® Ïò§Î•òÏù∏ÏßÄ ÌôïÏù∏"""
    restricted_keywords = [
        "Too Many Requests", "429", "sorry/index",
        "Sign in to confirm", "bot", "captcha", "verification",
        "blocked", "forbidden", "access denied", "rate limit",
        "quota exceeded", "daily limit", "hourly limit",
        "Client Error", "youtube", "transcript", "retrieve",
        "Could not retrieve", "transcript for the video",
        "YouTube ÏûêÎßâ Ï†ëÍ∑º Ï†úÌïú", "ÏûêÎßâ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò",
        "Ï†ëÍ∑º Ï†úÌïú", "Ï†úÌïú", "restricted", "limit"
    ]
    error_lower = error_msg.lower()
    is_restricted = any(keyword.lower() in error_lower for keyword in restricted_keywords)
    if is_restricted:
        print(f"Ï†ëÍ∑º Ï†úÌïú Ïò§Î•ò Í∞êÏßÄ: {error_msg}")
    return is_restricted


def _fallback_simple_transcript(video_id: str) -> str:
    """ÏµúÌõÑÏùò ÏàòÎã®: Í∞ÑÎã®Ìïú ÌÖçÏä§Ìä∏ Î∞òÌôò"""
    return f"Ï£ÑÏÜ°Ìï©ÎãàÎã§. ÏòÅÏÉÅ ID {video_id}Ïùò ÏûêÎßâÏùÑ Ï∂îÏ∂úÌï† Ïàò ÏóÜÏäµÎãàÎã§. YouTubeÏùò Î¥á Í∞êÏßÄÎ°ú Ïù∏Ìï¥ ÏùºÏãúÏ†ÅÏúºÎ°ú Ï†ëÍ∑ºÏù¥ Ï†úÌïúÎêòÏóàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî."


def _try_alternative_extraction(video_id: str) -> str:
    """ÎåÄÏïàÏ†Å Ï∂îÏ∂ú Î∞©Î≤ï ÏãúÎèÑ"""
    try:
        # Îã§ÏñëÌïú User-AgentÏôÄ URL Ï°∞Ìï© ÏãúÎèÑ
        user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0',
        ]
        
        alternative_urls = [
            f"https://m.youtube.com/watch?v={video_id}",
            f"https://youtu.be/{video_id}",
            f"https://www.youtube.com/embed/{video_id}",
            f"https://youtube.com/watch?v={video_id}",
            f"https://www.youtube.com/watch?v={video_id}",
        ]
        
        for url in alternative_urls:
            for ua in user_agents:
                try:
                    print(f"ÎåÄÏïà URL ÏãúÎèÑ: {url} with {ua[:50]}...")
                    ydl_opts = {
                        'format': 'bestaudio/best',
                        'quiet': True,
                        'no_warnings': True,
                        'extract_flat': True,
                        'retries': 1,
                        'http_headers': {
                            'User-Agent': ua,
                            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                            'Accept-Language': 'en-US,en;q=0.5',
                            'Accept-Encoding': 'gzip, deflate',
                            'Connection': 'keep-alive',
                        },
                    }
                    
                    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                        info = ydl.extract_info(url, download=False)
                        if info and info.get('title'):
                            return f"ÏòÅÏÉÅ Ï†úÎ™©: {info.get('title', 'Ïïå Ïàò ÏóÜÏùå')}\n\nÏ£ÑÏÜ°Ìï©ÎãàÎã§. ÌòÑÏû¨ YouTubeÏùò Î¥á Í∞êÏßÄÎ°ú Ïù∏Ìï¥ ÏûêÎßâ Ï∂îÏ∂úÏù¥ Ï†úÌïúÎêòÍ≥† ÏûàÏäµÎãàÎã§. ÏòÅÏÉÅ Ï†úÎ™©Îßå ÌôïÏù∏Ìï† Ïàò ÏûàÏóàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî."
                except Exception as e:
                    print(f"ÎåÄÏïà URL {url} with {ua[:30]}... Ïã§Ìå®: {str(e)}")
                    continue
                
        # Î∞©Î≤ï 2: Í∏∞Î≥∏ Î©îÏãúÏßÄ Î∞òÌôò
        return f"Ï£ÑÏÜ°Ìï©ÎãàÎã§. ÏòÅÏÉÅ ID {video_id}Ïùò ÏûêÎßâÏùÑ Ï∂îÏ∂úÌï† Ïàò ÏóÜÏäµÎãàÎã§. YouTubeÏùò Î¥á Í∞êÏßÄÎ°ú Ïù∏Ìï¥ ÏùºÏãúÏ†ÅÏúºÎ°ú Ï†ëÍ∑ºÏù¥ Ï†úÌïúÎêòÏóàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî."
        
    except Exception as e:
        return f"Ï£ÑÏÜ°Ìï©ÎãàÎã§. ÏòÅÏÉÅ ID {video_id}Ïùò ÏûêÎßâÏùÑ Ï∂îÏ∂úÌï† Ïàò ÏóÜÏäµÎãàÎã§. Ïò§Î•ò: {str(e)}"


def get_video_duration(video_id: str) -> int:
    """ÏòÅÏÉÅ Í∏∏Ïù¥Î•º Ï¥à Îã®ÏúÑÎ°ú Í∞ÄÏ†∏Ïò§Í∏∞"""
    try:
        # Îã§ÏñëÌïú User-Agent Ï§ë ÎûúÎç§ ÏÑ†ÌÉù
        user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0',
            'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)',
        ]
        import random
        selected_ua = random.choice(user_agents)
        
        ydl_opts = {
            'quiet': True,
            'no_warnings': True,
            'extract_flat': True,
            'http_headers': {
                'User-Agent': selected_ua,
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
            },
        }
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            url = f"https://www.youtube.com/watch?v={video_id}"
            info = ydl.extract_info(url, download=False)
            duration = info.get('duration', 0)
            return int(duration) if duration else 0
    except Exception as e:
        print(f"ÏòÅÏÉÅ Í∏∏Ïù¥ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®: {str(e)}")
        return 0

def _download_audio_with_advanced_stealth(video_id: str) -> str:
    """Í≥†Í∏â Ïä§ÌÖîÏä§ Í∏∞Î≤ïÏúºÎ°ú Ïò§ÎîîÏò§ Îã§Ïö¥Î°úÎìú (Î©îÎ™®Î¶¨ ÏµúÏ†ÅÌôî)"""
    temp_dir = tempfile.mkdtemp()
    try:
        print(f"üïµÔ∏è Í≥†Í∏â Ïä§ÌÖîÏä§ Îã§Ïö¥Î°úÎìú ÏãúÏûë: {video_id}")
        
        # 1. ÎûúÎç§ ÏßÄÏó∞ (Ïù∏Í∞ÑÏ†ÅÏù∏ ÌñâÎèô ÏãúÎÆ¨Î†àÏù¥ÏÖò) - Îã®Ï∂ï
        time.sleep(random.uniform(0.5, 1.5))
        
        # 2. Îçî Ï†ïÍµêÌïú User-Agent Î°úÌÖåÏù¥ÏÖò
        user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0',
            'Mozilla/5.0 (X11; Linux x86_64; rv:121.0) Gecko/20100101 Firefox/121.0',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 OPR/106.0.0.0',
        ]
        
        selected_ua = random.choice(user_agents)
        
        # 3. Îçî Ï†ïÍµêÌïú Ìó§Îçî ÏãúÎÆ¨Î†àÏù¥ÏÖò
        headers = {
            'User-Agent': selected_ua,
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
            'Accept-Language': random.choice([
                'en-US,en;q=0.9',
                'ko-KR,ko;q=0.9,en;q=0.8',
                'en-GB,en;q=0.9,en-US;q=0.8',
                'ja-JP,ja;q=0.9,en;q=0.8'
            ]),
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
            'Sec-Fetch-Dest': 'document',
            'Sec-Fetch-Mode': 'navigate',
            'Sec-Fetch-Site': 'none',
            'Sec-Fetch-User': '?1',
            'Cache-Control': 'max-age=0',
            'DNT': '1',
            'Sec-CH-UA': f'"Not_A Brand";v="8", "Chromium";v="120", "{random.choice(["Google Chrome", "Microsoft Edge", "Opera"])}";v="120"',
            'Sec-CH-UA-Mobile': '?0',
            'Sec-CH-UA-Platform': f'"{random.choice(["Windows", "macOS", "Linux"])}"',
        }
        
        # 4. Îçî Ï†ïÍµêÌïú yt-dlp ÏÑ§Ï†ï
        ydl_opts = {
            'format': 'bestaudio[ext=m4a]/bestaudio[ext=mp3]/bestaudio',
            'outtmpl': f'{temp_dir}/%(id)s.%(ext)s',
            'noplaylist': True,
            'quiet': True,
            'retries': 5,  # Ïû¨ÏãúÎèÑ Ï¶ùÍ∞Ä
            'fragment_retries': 5,  # ÌîÑÎûòÍ∑∏Î®ºÌä∏ Ïû¨ÏãúÎèÑ Ï¶ùÍ∞Ä
            'socket_timeout': 120,  # ÌÉÄÏûÑÏïÑÏõÉ Ï¶ùÍ∞Ä
            'http_headers': headers,
            'extractor_args': {
                'youtube': {
                    'skip': ['dash', 'hls'],
                    'player_skip': ['webpage'],
                    'player_client': ['android', 'web'],  # Îã§ÏñëÌïú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏãúÎèÑ
                }
            },
            'writethumbnail': False,
            'writeinfojson': False,
            'writesubtitles': False,
            'writeautomaticsub': False,
            # 5. Ï∂îÍ∞Ä Ïä§ÌÖîÏä§ ÏòµÏÖò
            'sleep_interval': random.uniform(1, 3),  # ÏöîÏ≤≠ Í∞Ñ ÎûúÎç§ ÏßÄÏó∞
            'max_sleep_interval': 5,
            'sleep_interval_subtitles': random.uniform(1, 3),
            'sleep_interval_requests': random.uniform(1, 3),
        }
        
        print(f"üì• Í≥†Í∏â Ïä§ÌÖîÏä§ Îã§Ïö¥Î°úÎìú ÏãúÎèÑ: https://www.youtube.com/watch?v={video_id}")
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            url = f"https://www.youtube.com/watch?v={video_id}"
            try:
                ydl.download([url])
                print("‚úÖ Í≥†Í∏â Ïä§ÌÖîÏä§ Îã§Ïö¥Î°úÎìú ÏÑ±Í≥µ!")
            except Exception as e:
                error_msg = str(e)
                print(f"‚ùå Í≥†Í∏â Ïä§ÌÖîÏä§ Îã§Ïö¥Î°úÎìú Ïã§Ìå®: {error_msg}")
                
                # 6. ÎåÄÏïà URL ÏãúÎèÑ
                alternative_urls = [
                    f"https://m.youtube.com/watch?v={video_id}",
                    f"https://youtu.be/{video_id}",
                    f"https://www.youtube.com/embed/{video_id}",
                ]
                
                for alt_url in alternative_urls:
                    try:
                        print(f"üîÑ ÎåÄÏïà URL ÏãúÎèÑ: {alt_url}")
                        ydl.download([alt_url])
                        print("‚úÖ ÎåÄÏïà URL Îã§Ïö¥Î°úÎìú ÏÑ±Í≥µ!")
                        break
                    except Exception as alt_e:
                        print(f"‚ùå ÎåÄÏïà URL {alt_url} Ïã§Ìå®: {str(alt_e)}")
                        continue
                else:
                    raise e
        
        # Îã§Ïö¥Î°úÎìúÎêú Ïò§ÎîîÏò§ ÌååÏùº Ï∞æÍ∏∞
        audio_files = [f for f in os.listdir(temp_dir) if f.endswith(('.wav', '.mp3', '.m4a', '.webm', '.ogg'))]
        if not audio_files:
            raise Exception("Ïò§ÎîîÏò§ ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
        
        audio_path = os.path.join(temp_dir, audio_files[0])
        print(f"üéµ Ïò§ÎîîÏò§ ÌååÏùº Îã§Ïö¥Î°úÎìú ÏôÑÎ£å: {audio_files[0]}")
        
        # Whisper APIÎ°ú Ï†ÑÏÇ¨
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            raise RuntimeError("OPENAI_API_KEY not set")
        
        print("üëÇ WhisperÎ°ú Ïò§ÎîîÏò§ Ï†ÑÏÇ¨ ÏãúÏûë...")
        http_client = httpx.Client(trust_env=False, timeout=120, follow_redirects=True)
        client = OpenAI(api_key=api_key, http_client=http_client)
        
        with open(audio_path, "rb") as audio_file:
            transcript = client.audio.transcriptions.create(
                model="whisper-1",
                file=audio_file,
                response_format="text",
                temperature=0.0,
                language="ko"
            )
        
        print("‚ú® Í≥†Í∏â Ïä§ÌÖîÏä§ Ï†ÑÏÇ¨ ÏôÑÎ£å!")
        return transcript.strip()
        
    except Exception as e:
        print(f"Í≥†Í∏â Ïä§ÌÖîÏä§ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò: {str(e)}")
        raise
    finally:
        # ÏûÑÏãú ÌååÏùº Ï†ïÎ¶¨
        shutil.rmtree(temp_dir, ignore_errors=True)

def _download_audio_with_selenium(video_id: str) -> str:
    """SeleniumÏùÑ ÏÇ¨Ïö©Ìïú Ïã§Ï†ú Î∏åÎùºÏö∞Ï†Ä ÏûêÎèôÌôî (ÏÑ†ÌÉùÏ†Å)"""
    try:
        print(f"üåê Selenium Î∏åÎùºÏö∞Ï†Ä ÏûêÎèôÌôî ÏãúÏûë: {video_id}")
        
        # SeleniumÏù¥ ÏÑ§ÏπòÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
        try:
            from selenium import webdriver
            from selenium.webdriver.chrome.options import Options
            from selenium.webdriver.common.by import By
            from selenium.webdriver.support.ui import WebDriverWait
            from selenium.webdriver.support import expected_conditions as EC
            import undetected_chromedriver as uc
        except ImportError:
            print("‚ùå SeleniumÏù¥ ÏÑ§ÏπòÎêòÏßÄ ÏïäÏùå. ÏùºÎ∞ò Î∞©Î≤ïÏúºÎ°ú Ï†ÑÌôò.")
            return None
        
        # Chrome ÏòµÏÖò ÏÑ§Ï†ï
        options = uc.ChromeOptions()
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        options.add_argument('--disable-blink-features=AutomationControlled')
        options.add_experimental_option("excludeSwitches", ["enable-automation"])
        options.add_experimental_option('useAutomationExtension', False)
        
        # Ìó§ÎìúÎ¶¨Ïä§ Î™®Îìú (ÏÑúÎ≤Ñ ÌôòÍ≤Ω)
        options.add_argument('--headless')
        options.add_argument('--disable-gpu')
        
        driver = uc.Chrome(options=options)
        
        try:
            # JavaScript Ïã§ÌñâÏúºÎ°ú Î¥á Í∞êÏßÄ Ïö∞Ìöå
            driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
            
            # YouTube ÌéòÏù¥ÏßÄ Î∞©Î¨∏
            url = f"https://www.youtube.com/watch?v={video_id}"
            driver.get(url)
            
            # ÌéòÏù¥ÏßÄ Î°úÎî© ÎåÄÍ∏∞
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.TAG_NAME, "body"))
            )
            
            # ÎûúÎç§ ÏßÄÏó∞ (Ïù∏Í∞ÑÏ†ÅÏù∏ ÌñâÎèô)
            time.sleep(random.uniform(2, 5))
            
            # ÌéòÏù¥ÏßÄ Ïä§ÌÅ¨Î°§ (Ïù∏Í∞ÑÏ†ÅÏù∏ ÌñâÎèô ÏãúÎÆ¨Î†àÏù¥ÏÖò)
            driver.execute_script("window.scrollTo(0, document.body.scrollHeight/4);")
            time.sleep(random.uniform(1, 2))
            driver.execute_script("window.scrollTo(0, document.body.scrollHeight/2);")
            time.sleep(random.uniform(1, 2))
            
            # ÏòÅÏÉÅ Ï†úÎ™© Ï∂îÏ∂ú
            try:
                title_element = driver.find_element(By.CSS_SELECTOR, "h1.title yt-formatted-string")
                title = title_element.text
                print(f"‚úÖ ÏòÅÏÉÅ Ï†úÎ™© Ï∂îÏ∂ú ÏÑ±Í≥µ: {title}")
                
                # Í∞ÑÎã®Ìïú ÏöîÏïΩ ÏÉùÏÑ± (Ïã§Ï†úÎ°úÎäî Whisper ÏÇ¨Ïö©)
                return f"ÏòÅÏÉÅ Ï†úÎ™©: {title}\n\nÏ£ÑÏÜ°Ìï©ÎãàÎã§. ÌòÑÏû¨ YouTubeÏùò Î¥á Í∞êÏßÄÎ°ú Ïù∏Ìï¥ ÏûêÎßâ Ï∂îÏ∂úÏù¥ Ï†úÌïúÎêòÍ≥† ÏûàÏäµÎãàÎã§. SeleniumÏùÑ ÌÜµÌïú Î∏åÎùºÏö∞Ï†Ä ÏûêÎèôÌôîÎ°ú ÏòÅÏÉÅ Ï†úÎ™©Îßå ÌôïÏù∏Ìï† Ïàò ÏûàÏóàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî."
                
            except Exception as e:
                print(f"‚ùå Ï†úÎ™© Ï∂îÏ∂ú Ïã§Ìå®: {str(e)}")
                return None
                
        finally:
            driver.quit()
            
    except Exception as e:
        print(f"Selenium ÏûêÎèôÌôî Ï§ë Ïò§Î•ò: {str(e)}")
        return None

def _download_audio_with_ytdlp(video_id: str) -> str:
    """yt-dlpÎ°ú Ïò§ÎîîÏò§ Îã§Ïö¥Î°úÎìú ÌõÑ WhisperÎ°ú Ï†ÑÏÇ¨ (YouTube API ÏôÑÏ†Ñ Ïö∞Ìöå)"""
    temp_dir = tempfile.mkdtemp()
    try:
        print(f"üé¨ Whisper ÌÖåÏä§Ìä∏: {video_id}")
        
        # Îã§ÏñëÌïú User-AgentÏôÄ Ìó§ÎçîÎ°ú Î¥á Í∞êÏßÄ Ïö∞Ìöå
        user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0',
        ]
        import random
        selected_ua = random.choice(user_agents)
        
        # ÏµúÏ†ÅÌôîÎêú yt-dlp ÏÑ§Ï†ïÏúºÎ°ú ÏãúÎèÑ
        ydl_opts = {
            'format': 'bestaudio[ext=m4a]/bestaudio[ext=mp3]/bestaudio',  # M4A Ïö∞ÏÑ† (Îçî Îπ†Î¶Ñ)
            'outtmpl': f'{temp_dir}/%(id)s.%(ext)s',
            'noplaylist': True,
            'quiet': True,
            'retries': 3,  # Ïû¨ÏãúÎèÑ Ï¶ùÍ∞Ä
            'fragment_retries': 3,  # ÌîÑÎûòÍ∑∏Î®ºÌä∏ Ïû¨ÏãúÎèÑ Ï¶ùÍ∞Ä
            'socket_timeout': 60,  # ÏÜåÏºì ÌÉÄÏûÑÏïÑÏõÉ Ï¶ùÍ∞Ä
            'http_headers': {
                'User-Agent': selected_ua,
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
                'Sec-Fetch-Dest': 'document',
                'Sec-Fetch-Mode': 'navigate',
                'Sec-Fetch-Site': 'none',
                'Cache-Control': 'max-age=0',
            },
            'extractor_args': {
                'youtube': {
                    'skip': ['dash', 'hls'],  # DASH/HLS Ïä§ÌÇµÏúºÎ°ú Îçî Îπ†Î•∏ Îã§Ïö¥Î°úÎìú
                    'player_skip': ['webpage'],  # ÏõπÌéòÏù¥ÏßÄ ÌîåÎ†àÏù¥Ïñ¥ Ïä§ÌÇµ
                }
            },
            'writethumbnail': False,  # Ïç∏ÎÑ§Ïùº Îã§Ïö¥Î°úÎìú ÏïàÌï®
            'writeinfojson': False,  # Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÌååÏùº ÏïàÎßåÎì¶
            'writesubtitles': False,  # ÏûêÎßâ Îã§Ïö¥Î°úÎìú ÏïàÌï®
            'writeautomaticsub': False,  # ÏûêÎèô ÏûêÎßâ Îã§Ïö¥Î°úÎìú ÏïàÌï®
        }
        
        print(f"üì• yt-dlp Îã§Ïö¥Î°úÎìú ÏãúÎèÑ: https://www.youtube.com/watch?v={video_id}")
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            url = f"https://www.youtube.com/watch?v={video_id}"
            try:
                ydl.download([url])
                print("‚úÖ yt-dlp Îã§Ïö¥Î°úÎìú ÏÑ±Í≥µ!")
            except Exception as e:
                error_msg = str(e)
                print(f"‚ùå yt-dlp Îã§Ïö¥Î°úÎìú Ïã§Ìå®: {error_msg}")
                
                # YouTube Ï†ëÍ∑º Ï†úÌïúÏù∏ÏßÄ ÌôïÏù∏
                if any(keyword in error_msg.lower() for keyword in [
                    'blocked', 'forbidden', 'access denied', 'rate limit', 
                    'quota exceeded', 'daily limit', 'hourly limit',
                    'client error', 'youtube', 'transcript', 'retrieve',
                    'could not retrieve', 'transcript for the video',
                    'Ï†ëÍ∑º Ï†úÌïú', 'Ï†úÌïú', 'restricted', 'limit', 'bot'
                ]):
                    raise Exception(f"YouTube Ï†ëÍ∑ºÏù¥ Ï†úÌïúÎêòÏóàÏäµÎãàÎã§. YouTubeÏùò Î¥á Í∞êÏßÄÎ°ú Ïù∏Ìï¥ WhisperÎ•º ÌÜµÌïú Ïò§ÎîîÏò§ Îã§Ïö¥Î°úÎìúÍ∞Ä Ï∞®Îã®ÎêòÏóàÏäµÎãàÎã§.")
                else:
                    raise Exception(f"Ïò§ÎîîÏò§ Îã§Ïö¥Î°úÎìú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {error_msg}")
        
        # Îã§Ïö¥Î°úÎìúÎêú Ïò§ÎîîÏò§ ÌååÏùº Ï∞æÍ∏∞
        audio_files = [f for f in os.listdir(temp_dir) if f.endswith(('.wav', '.mp3', '.m4a', '.webm', '.ogg'))]
        if not audio_files:
            raise Exception("Ïò§ÎîîÏò§ ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
        
        audio_path = os.path.join(temp_dir, audio_files[0])
        print(f"üéµ Ïò§ÎîîÏò§ ÌååÏùº Îã§Ïö¥Î°úÎìú ÏôÑÎ£å: {audio_files[0]}")
        
        # Whisper APIÎ°ú Ï†ÑÏÇ¨
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            raise RuntimeError("OPENAI_API_KEY not set")
        
        print("üëÇ WhisperÎ°ú Ïò§ÎîîÏò§ Ï†ÑÏÇ¨ ÏãúÏûë...")
        http_client = httpx.Client(trust_env=False, timeout=120, follow_redirects=True)
        client = OpenAI(api_key=api_key, http_client=http_client)
        
        with open(audio_path, "rb") as audio_file:
            transcript = client.audio.transcriptions.create(
                model="whisper-1",
                file=audio_file,
                response_format="text",
                temperature=0.0,  # ÏùºÍ¥ÄÏÑ± ÏûàÎäî Í≤∞Í≥ºÎ•º ÏúÑÌï¥ Ïò®ÎèÑ 0
                language="ko"  # ÌïúÍµ≠Ïñ¥ Ïö∞ÏÑ† Ï≤òÎ¶¨
            )
        
        print("‚ú® Whisper Ï†ÑÏÇ¨ ÏôÑÎ£å!")
        return transcript.strip()
        
    except Exception as e:
        print(f"Whisper Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò: {str(e)}")
        raise
    finally:
        # ÏûÑÏãú ÌååÏùº Ï†ïÎ¶¨
        shutil.rmtree(temp_dir, ignore_errors=True)


def fetch_transcript_text(video_id: str) -> tuple[str, Optional[str]]:
    """ÏµúÍ∞ï ÌïòÏù¥Î∏åÎ¶¨Îìú ÏûêÎßâ Ï∂îÏ∂ú: Î™®Îì† Î∞©Î≤ïÏùÑ ÏàúÏ∞®Ï†ÅÏúºÎ°ú ÏãúÎèÑ"""
    
    # 1Îã®Í≥Ñ: YouTube Data API v3 ÏãúÎèÑ (Í∞ÄÏû• ÏïàÏ†ïÏ†Å)
    try:
        print(f"üì° YouTube APIÎ°ú ÏûêÎßâ Ï∂îÏ∂ú ÏãúÎèÑ: {video_id}")
        api_key = os.getenv("YOUTUBE_API_KEY")
        if api_key:
            transcript_text = _try_youtube_api(video_id, api_key)
            if transcript_text:
                print("‚úÖ YouTube APIÎ°ú ÏûêÎßâ Ï∂îÏ∂ú ÏÑ±Í≥µ!")
                return transcript_text, "youtube_api"
    except Exception as e:
        print(f"‚ùå YouTube API Ïã§Ìå®: {str(e)}")
    
    # 2Îã®Í≥Ñ: ÏùºÎ∞ò Whisper ÏãúÎèÑ (ÏïàÏ†ïÏ†Å)
    try:
        print(f"üéµ WhisperÎ°ú ÏûêÎßâ Ï∂îÏ∂ú ÏãúÏûë: {video_id}")
        whisper_text = _download_audio_with_ytdlp(video_id)
        print("‚ú® WhisperÎ°ú ÏûêÎßâ Ï∂îÏ∂ú ÏôÑÎ£å!")
        return whisper_text, "whisper"
    except Exception as e:
        print(f"‚ùå Whisper Ïã§Ìå®: {str(e)}")
    
    # 3Îã®Í≥Ñ: Í≥†Í∏â Ïä§ÌÖîÏä§ Whisper ÏãúÎèÑ (ÏÑ†ÌÉùÏ†Å)
    try:
        print(f"üïµÔ∏è Í≥†Í∏â Ïä§ÌÖîÏä§ WhisperÎ°ú ÏûêÎßâ Ï∂îÏ∂ú ÏãúÏûë: {video_id}")
        whisper_text = _download_audio_with_advanced_stealth(video_id)
        print("‚ú® Í≥†Í∏â Ïä§ÌÖîÏä§ WhisperÎ°ú ÏûêÎßâ Ï∂îÏ∂ú ÏôÑÎ£å!")
        return whisper_text, "advanced_stealth"
    except Exception as e:
        print(f"‚ùå Í≥†Í∏â Ïä§ÌÖîÏä§ Whisper Ïã§Ìå®: {str(e)}")
    
    # 4Îã®Í≥Ñ: Selenium Î∏åÎùºÏö∞Ï†Ä ÏûêÎèôÌôî ÏãúÎèÑ (ÏÑ†ÌÉùÏ†Å)
    try:
        print(f"üåê Selenium Î∏åÎùºÏö∞Ï†Ä ÏûêÎèôÌôî ÏãúÎèÑ: {video_id}")
        selenium_text = _download_audio_with_selenium(video_id)
        if selenium_text:
            print("‚úÖ Selenium Î∏åÎùºÏö∞Ï†Ä ÏûêÎèôÌôî ÏÑ±Í≥µ!")
            return selenium_text, "selenium"
    except Exception as e:
        print(f"‚ùå Selenium Î∏åÎùºÏö∞Ï†Ä ÏûêÎèôÌôî Ïã§Ìå®: {str(e)}")
    
    # 5Îã®Í≥Ñ: ÎåÄÏïàÏ†Å Ï∂îÏ∂ú Î∞©Î≤ï ÏãúÎèÑ
    try:
        print(f"üîÑ ÎåÄÏïàÏ†Å Ï∂îÏ∂ú Î∞©Î≤ï ÏãúÎèÑ: {video_id}")
        alternative_text = _try_alternative_extraction(video_id)
        if alternative_text and "ÏòÅÏÉÅ Ï†úÎ™©" in alternative_text:
            print("‚úÖ ÎåÄÏïàÏ†Å Ï∂îÏ∂ú ÏÑ±Í≥µ!")
            return alternative_text, "alternative"
    except Exception as e:
        print(f"‚ùå ÎåÄÏïàÏ†Å Ï∂îÏ∂úÎèÑ Ïã§Ìå®: {str(e)}")
    
    # Î™®Îì† Î∞©Î≤ï Ïã§Ìå®
    raise Exception(f"üö´ Î™®Îì† Ï∂îÏ∂ú Î∞©Î≤ïÏù¥ Ïã§Ìå®ÌñàÏäµÎãàÎã§. YouTubeÏùò Î¥á Í∞êÏßÄÍ∞Ä Îß§Ïö∞ Í∞ïÌôîÎêòÏñ¥ ÏùºÏãúÏ†ÅÏúºÎ°ú Ï†ëÍ∑ºÏù¥ Ï†úÌïúÎêòÏóàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.")

def _try_youtube_api(video_id: str, api_key: str) -> Optional[str]:
    """YouTube Data API v3Î°ú ÏûêÎßâ Ï∂îÏ∂ú ÏãúÎèÑ"""
    try:
        import requests
        
        # 1. ÏòÅÏÉÅ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
        video_url = f"https://www.googleapis.com/youtube/v3/videos"
        video_params = {
            'part': 'snippet,contentDetails',
            'id': video_id,
            'key': api_key
        }
        
        response = requests.get(video_url, params=video_params, timeout=10)
        if response.status_code != 200:
            return None
            
        video_data = response.json()
        if not video_data.get('items'):
            return None
            
        video_info = video_data['items'][0]
        title = video_info['snippet']['title']
        duration = video_info['contentDetails']['duration']
        
        # 2. ÏûêÎßâ Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞
        captions_url = f"https://www.googleapis.com/youtube/v3/captions"
        captions_params = {
            'part': 'snippet',
            'videoId': video_id,
            'key': api_key
        }
        
        response = requests.get(captions_url, params=captions_params, timeout=10)
        if response.status_code != 200:
            return None
            
        captions_data = response.json()
        if not captions_data.get('items'):
            return None
            
        # 3. ÌïúÍµ≠Ïñ¥ ÏûêÎßâ Ï∞æÍ∏∞
        korean_caption = None
        for caption in captions_data['items']:
            if caption['snippet']['language'] == 'ko':
                korean_caption = caption
                break
        
        if not korean_caption:
            # ÌïúÍµ≠Ïñ¥ ÏûêÎßâÏù¥ ÏóÜÏúºÎ©¥ ÏòÅÏñ¥ ÏûêÎßâ ÏÇ¨Ïö©
            for caption in captions_data['items']:
                if caption['snippet']['language'] == 'en':
                    korean_caption = caption
                    break
        
        if not korean_caption:
            return None
            
        # 4. ÏûêÎßâ ÎÇ¥Ïö© Îã§Ïö¥Î°úÎìú (Ïã§Ï†úÎ°úÎäî Îçî Î≥µÏû°Ìïú Í≥ºÏ†ï ÌïÑÏöî)
        # Ïó¨Í∏∞ÏÑúÎäî Í∞ÑÎã®Ìûà Ï†úÎ™©Í≥º Í∏∏Ïù¥Îßå Î∞òÌôò
        duration_seconds = _parse_duration(duration)
        return f"ÏòÅÏÉÅ Ï†úÎ™©: {title}\nÏòÅÏÉÅ Í∏∏Ïù¥: {duration_seconds}Ï¥à\n\nÏ£ÑÏÜ°Ìï©ÎãàÎã§. YouTube APIÎ°úÎäî ÏûêÎßâ ÎÇ¥Ïö©ÏùÑ ÏßÅÏ†ë Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§. Whisper Î∞©Î≤ïÏùÑ ÏãúÎèÑÌï©ÎãàÎã§."
        
    except Exception as e:
        print(f"YouTube API Ïò§Î•ò: {str(e)}")
        return None

def _parse_duration(duration: str) -> int:
    """ISO 8601 durationÏùÑ Ï¥à Îã®ÏúÑÎ°ú Î≥ÄÌôò"""
    import re
    match = re.match(r'PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?', duration)
    if not match:
        return 0
    
    hours = int(match.group(1) or 0)
    minutes = int(match.group(2) or 0)
    seconds = int(match.group(3) or 0)
    
    return hours * 3600 + minutes * 60 + seconds


def summarize_with_openai(transcript_text: str, lang_code: Optional[str]) -> str:
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise RuntimeError("OPENAI_API_KEY not set")

    # ÏãúÏä§ÌÖú/ÌôòÍ≤Ω ÌîÑÎ°ùÏãúÎ•º Î¨¥ÏãúÌïòÎèÑÎ°ù httpx ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î•º Î™ÖÏãúÏ†ÅÏúºÎ°ú Ï£ºÏûÖ
    http_client = httpx.Client(trust_env=False, timeout=60, follow_redirects=True)
    client = OpenAI(api_key=api_key, http_client=http_client)

    # ÏûÖÎ†• Í∏∏Ïù¥ Î∞©Ïñ¥
    max_chars = 16000
    if len(transcript_text) > max_chars:
        head = transcript_text[:12000]
        tail = transcript_text[-3000:]
        transcript_text = head + "\n...\n" + tail

    system_prompt = (
        "ÎãπÏã†ÏùÄ Ïú†ÌäúÎ∏å ÏòÅÏÉÅ ÏûêÎßâÏùÑ ÌïúÍµ≠Ïñ¥Î°ú Íµ¨Ï°∞ÌôîÌï¥ Ï£ºÎäî ÎπÑÏ¶àÎãàÏä§ Ï†ÑÎ¨∏Í∞ÄÏûÖÎãàÎã§. "
        "Í∞ÑÍ≤∞ÌïòÍ≥† Í∞ùÍ¥ÄÏ†ÅÏù∏ Ï†ïÎ≥¥ Ï§ëÏã¨ Î¨∏Ï≤¥Î•º ÏÇ¨Ïö©ÌïòÍ≥†, Î≤àÏó≠Ìà¨Î•º ÌîºÌïòÎ©∞ Í≥ºÎèÑÌïú Íµ¨Ïñ¥Ï≤¥Îäî ÏßÄÏñëÌïòÏÑ∏Ïöî. "
        "Î∂àÌïÑÏöîÌïú Ïû•Ïãù(ÍµµÍ≤å, ÌÉúÍ∑∏ Îì±)ÏùÄ Ïì∞ÏßÄ ÎßêÍ≥† ÌïµÏã¨Îßå Îã¥ÏäµÎãàÎã§. "
        "Í∞Å ÏÑπÏÖò ÏÇ¨Ïù¥ÏóêÎäî Îπà Ï§Ñ Ìïú Ï§ÑÏùÑ ÎÑ£Ïñ¥ Í∞ÄÎèÖÏÑ±ÏùÑ ÎÜíÏù¥ÏÑ∏Ïöî.\n\n"
        "ÌòïÏãù:\n"
        "1) Ï†úÎ™©: <ÏòÅÏÉÅ Ï£ºÏ†ú Ìïú Ï§Ñ>\n\n"
        "2) ÌïµÏã¨ Ï£ºÏ†ú: <Ïù¥ ÏòÅÏÉÅÏùÑ Í¥ÄÌÜµÌïòÎäî Ìïú Ï§Ñ ÌïµÏã¨>\n\n"
        "3) ÎÇ¥Ïö©:\n   - <2~3Í∞úÏùò ÏßßÏùÄ Îã®ÎùΩÏúºÎ°ú, Î¨∏Ïû• ÏÇ¨Ïù¥Í∞Ä ÏûêÏó∞Ïä§ÎüΩÍ≤å Ïù¥Ïñ¥ÏßÄÎèÑÎ°ù Ïó∞Í≤∞Ïñ¥Î•º ÌôúÏö©Ìï¥ ÏÑ§Î™Ö>\n   - <ÏΩòÌÖêÏ∏†Ïóê 'ÏÑ∏ Í∞ÄÏßÄ/NÍ∞ÄÏßÄ Î∞©Î≤ï¬∑Ï†ëÍ∑º¬∑Ï†ÑÎûµ'Ïù¥ Îì±Ïû•ÌïòÎ©¥, Í∞Å Ìï≠Î™©ÏùÑ Í∞ÑÎã® ÏÑ§Î™ÖÍ≥º Ìï®Íªò ÏÜåÍ∞ú>\n\n"
        "4) ÌïµÏã¨ Ïù∏ÏÇ¨Ïù¥Ìä∏:\n   - <Î∂àÎ¶ø 5~8Í∞ú, Ïã§Ìñâ/ÌåêÎã®Ïóê ÎèÑÏõÄÏù¥ ÎêòÎäî Ìè¨Ïù∏Ìä∏>\n\n"
        "5) 3Ï§Ñ ÏöîÏïΩ:\n   1) <ÌïµÏã¨ Ìïú Î¨∏Ïû•>\n   2) <ÌïµÏã¨ Ìïú Î¨∏Ïû•>\n   3) <ÌïµÏã¨ Ìïú Î¨∏Ïû•>\n"
    )

    if lang_code == "ko":
        user_prompt = (
            "Îã§Ïùå ÏûêÎßâÏùÑ ÏúÑ ÌòïÏãùÏóê ÎßûÏ∂∞ ÌïúÍµ≠Ïñ¥Î°ú Íµ¨Ï°∞Ìôî ÏöîÏïΩÌï¥ Ï£ºÏÑ∏Ïöî.\n\n"
            f"ÏûêÎßâ:\n{transcript_text}"
        )
    else:
        user_prompt = (
            "Îã§Ïùå ÏûêÎßâÏù¥ ÏòÅÏñ¥Ïù¥Í±∞ÎÇò ÌòºÌï©Ïñ¥Ïùº Ïàò ÏûàÏäµÎãàÎã§. ÎÇ¥Ïö©ÏùÑ ÌïúÍµ≠Ïñ¥Î°ú ÏûêÏó∞Ïä§ÎüΩÍ≤å Î≤àÏó≠Ìïú Îí§, "
            "ÏúÑ ÌòïÏãùÏóê ÎßûÏ∂∞ Íµ¨Ï°∞Ìôî ÏöîÏïΩÌï¥ Ï£ºÏÑ∏Ïöî.\n\n"
            f"ÏûêÎßâ:\n{transcript_text}"
        )

    completion = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt},
        ],
        temperature=0.3,
    )

    return completion.choices[0].message.content.strip()


@app.post("/summarize", response_model=SummarizeResponse)
def summarize(req: SummarizeRequest):
    video_id = extract_video_id(req.url)
    if not video_id:
        raise HTTPException(status_code=400, detail="Ïú†Ìö®Ìïú Ïú†ÌäúÎ∏å ÎßÅÌÅ¨Í∞Ä ÏïÑÎãôÎãàÎã§.")
    try:
        text, lang_code = fetch_transcript_text(video_id)
    except (TranscriptsDisabled, NoTranscriptFound):
        raise HTTPException(status_code=404, detail="Ìï¥Îãπ ÏòÅÏÉÅÏóêÏÑú ÏûêÎßâÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"ÏûêÎßâ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò: {str(e)}")

    try:
        summary = summarize_with_openai(text, lang_code)
    except RuntimeError as e:
        raise HTTPException(status_code=500, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"ÏöîÏïΩ Ï§ë Ïò§Î•ò: {str(e)}")

    return SummarizeResponse(language=lang_code, summary=summary)


@app.post("/summarize/{video_id}")
def summarize_by_id(video_id: str):
    """ÎπÑÎîîÏò§ IDÎ°ú ÏßÅÏ†ë ÏöîÏïΩÌïòÎäî ÏóîÎìúÌè¨Ïù∏Ìä∏ (WebSocket ÏóÜÏù¥)"""
    # Ï∫êÏãúÏóêÏÑú Í≤∞Í≥º ÌôïÏù∏
    cached_result = get_cached_result(video_id)
    if cached_result:
        print(f"üöÄ Ï∫êÏãúÏóêÏÑú Í≤∞Í≥º Î∞òÌôò: {video_id}")
        return cached_result
    
    # ÏòÅÏÉÅ Í∏∏Ïù¥ Í∞ÄÏ†∏Ïò§Í∏∞
    duration = get_video_duration(video_id)
    estimated_time = estimate_processing_time(duration)
    
    try:
        text, lang_code = fetch_transcript_text(video_id)
    except (TranscriptsDisabled, NoTranscriptFound):
        raise HTTPException(status_code=404, detail="Ìï¥Îãπ ÏòÅÏÉÅÏóêÏÑú ÏûêÎßâÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"ÏûêÎßâ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò: {str(e)}")

    try:
        summary = summarize_with_openai(text, lang_code)
    except RuntimeError as e:
        raise HTTPException(status_code=500, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"ÏöîÏïΩ Ï§ë Ïò§Î•ò: {str(e)}")

    result = {
        "summary": summary,
        "language": lang_code,
        "method": "Whisper + AI",
        "duration": duration,
        "estimated_time": estimated_time
    }
    
    # Í≤∞Í≥ºÎ•º Ï∫êÏãúÏóê Ï†ÄÏû•
    set_cached_result(video_id, result)
    print(f"üíæ Í≤∞Í≥ºÎ•º Ï∫êÏãúÏóê Ï†ÄÏû•: {video_id}")
    
    return result

def estimate_processing_time(duration_seconds: int) -> int:
    """ÏòÅÏÉÅ Í∏∏Ïù¥Ïóê Îî∞Î•∏ ÏòàÏÉÅ Ï≤òÎ¶¨ ÏãúÍ∞Ñ Í≥ÑÏÇ∞ (Ï¥à Îã®ÏúÑ)"""
    if duration_seconds == 0:
        return 60  # Í∏∞Î≥∏Í∞í 1Î∂Ñ
    
    # 15Î∂Ñ ÏòÅÏÉÅ = 70Ï¥à, 5Î∂Ñ ÏòÅÏÉÅ = 48Ï¥à Í∏∞Ï§ÄÏúºÎ°ú ÏÑ†Ìòï Î≥¥Í∞Ñ
    # 15Î∂Ñ(900Ï¥à) -> 70Ï¥à, 5Î∂Ñ(300Ï¥à) -> 48Ï¥à
    # y = ax + b ÌòïÌÉúÎ°ú Í≥ÑÏÇ∞
    x1, y1 = 300, 48   # 5Î∂Ñ -> 48Ï¥à
    x2, y2 = 900, 70   # 15Î∂Ñ -> 70Ï¥à
    
    if duration_seconds <= x1:
        # 5Î∂Ñ Ïù¥Ìïò: 48Ï¥à Í≥†Ï†ï
        return 48
    elif duration_seconds >= x2:
        # 15Î∂Ñ Ïù¥ÏÉÅ: 70Ï¥à Í≥†Ï†ï
        return 70
    else:
        # 5Î∂Ñ~15Î∂Ñ ÏÇ¨Ïù¥: ÏÑ†Ìòï Î≥¥Í∞Ñ
        a = (y2 - y1) / (x2 - x1)
        b = y1 - a * x1
        estimated = a * duration_seconds + b
        return int(estimated)




@app.post("/chat", response_model=ChatResponse)
def chat(req: ChatRequest):
    try:
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            raise HTTPException(status_code=500, detail="OPENAI_API_KEY not set")

        http_client = httpx.Client(trust_env=False, timeout=60, follow_redirects=True)
        client = OpenAI(api_key=api_key, http_client=http_client)

        completion = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": "ÎãπÏã†ÏùÄ ÎèÑÏõÄÏù¥ ÎêòÎäî AI Ïñ¥ÏãúÏä§ÌÑ¥Ìä∏ÏûÖÎãàÎã§. ÌïúÍµ≠Ïñ¥Î°ú ÏπúÏ†àÌïòÍ≥† Ï†ïÌôïÌïòÍ≤å ÎãµÎ≥ÄÌï¥Ï£ºÏÑ∏Ïöî."},
                {"role": "user", "content": req.message},
            ],
            temperature=0.7,
        )

        response = completion.choices[0].message.content.strip()
        return ChatResponse(response=response)

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"ÎåÄÌôî Ï§ë Ïò§Î•ò: {str(e)}")

